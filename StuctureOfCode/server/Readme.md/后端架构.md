å¤ªå¥½äº†ï¼Œè¿™ä¸€å¥—åˆšå¥½å¯ä»¥ä¸²æˆâ€œå®Œæ•´é¡¹ç›®æ•…äº‹çº¿â€ğŸ˜„
æˆ‘åˆ†ä¸‰æ®µç»™ä½ ï¼š

â¸»

â‘  å¯ç›´æ¥ç”¨çš„ GlobalExceptionHandlerï¼ˆé…åˆä½ ç°æœ‰ Result / BaseExceptionï¼‰
```
package com.sky.handler;

import com.sky.exception.BaseException;
import com.sky.result.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * å…¨å±€å¼‚å¸¸å¤„ç†å™¨
 * ç»Ÿä¸€æŠŠåç«¯å¼‚å¸¸ -> Result JSON è¿”å›ç»™å‰ç«¯
 */
@RestControllerAdvice   // = @ControllerAdvice + @ResponseBody
@Slf4j
public class GlobalExceptionHandler {

    /**
     * ä¸šåŠ¡å¼‚å¸¸ç»Ÿä¸€å¤„ç†
     * æ¯”å¦‚ï¼šOrderBusinessException / ShoppingCartBusinessException / AccountLockedException ç­‰
     */
    @ExceptionHandler(BaseException.class)
    public Result<String> handleBaseException(BaseException e) {
        log.warn("ä¸šåŠ¡å¼‚å¸¸: {}", e.getMessage());
        // è¿”å›ç»Ÿä¸€é”™è¯¯ç»“æ„ï¼šcode = 0, msg = å…·ä½“æç¤º
        return Result.error(e.getMessage());
    }

    /**
     * å…œåº•å¼‚å¸¸å¤„ç†ï¼ˆæœªé¢„æ–™çš„ RuntimeExceptionï¼‰
     * é˜²æ­¢å †æ ˆä¿¡æ¯ç›´æ¥æ³„éœ²ç»™å‰ç«¯
     */
    @ExceptionHandler(Exception.class)
    public Result<String> handleException(Exception e) {
        log.error("ç³»ç»Ÿå¼‚å¸¸: ", e);
        // ç»™å‰ç«¯ä¸€ä¸ªé€šç”¨æç¤ºï¼Œå…·ä½“é”™è¯¯çœ‹æ—¥å¿—
        return Result.error("æœåŠ¡å™¨å¼€å°å·®äº†ï¼Œè¯·ç¨åé‡è¯•");
    }
}
```

æ”¾åˆ° sky-server é‡Œï¼Œæ¯”å¦‚ com.sky.handler åŒ…ä¸‹å°±è¡Œã€‚
è¿™æ ·æ‰€æœ‰ throw new OrderBusinessException(...) / ShoppingCartBusinessException(...) æœ€ç»ˆéƒ½ä¼šå˜æˆç»Ÿä¸€çš„ Result.error(msg) è¿”å›ç»™å‰ç«¯ã€‚

â¸»

â‘¡ ä¸€é¡µâ€œé¡¹ç›®æ¶æ„è‡ªæˆ‘ä»‹ç»ç¨¿â€ï¼ˆé¢è¯•å¯ç›´æ¥èƒŒï¼‰

ä½ å¯ä»¥å½“æˆå›ç­”ï¼šâ€œè¯·ç®€å•ä»‹ç»ä¸€ä¸‹ä½ è¿™ä¸ªåå°é¡¹ç›®çš„æ¶æ„è®¾è®¡ï¼Ÿâ€

Our project follows a classic layered architecture with some enhancements.
At the top, we have REST controllers, such as CategoryController and OrderController, which receive DTOs from the frontend and return a unified Result response object.
Controllers delegate all business logic to service classes, for example OrderServiceImpl, where we handle validation, business rules, and transaction boundaries.
Services call mapper interfaces like OrderMapper and CategoryMapper. These mappers are implemented by MyBatis and execute SQL to read and write database entities such as Orders, Category, and AddressBook.

For data modeling we clearly separate three roles:
DTOs are used to receive request parameters from the client,
Entities map directly to database tables,
and VOs are used to shape response models returned to the frontend.
This separation keeps our APIs stable and decoupled from the persistence layer.

Authentication is stateless and based on JWT.
We define a JwtProperties class with @ConfigurationProperties(prefix = "sky.jwt") to bind JWT secrets and token TTL from application.yml.
After login we generate a JWT token, and a login interceptor validates the token on each request, extracts the user id, and stores it in a BaseContext using ThreadLocal.
This allows any service or aspect to call BaseContext.getCurrentId() to know who is making the request without passing the user id everywhere.

We also use Spring AOP to implement automatic audit field filling.
We created a custom annotation @AutoFill(OperationType.INSERT or UPDATE) on mapper methods and an AutoFillAspect.
The aspect intercepts mapper calls, reads the operation type, and uses reflection to set common audit fields like createTime, createUser, updateTime, and updateUser based on the current user from BaseContext.
This removes duplicated code in every service and centralizes audit logic.

For error handling we built a small exception hierarchy.
BaseException extends RuntimeException, and concrete business exceptions, such as OrderBusinessException and ShoppingCartBusinessException, extend BaseException.
A GlobalExceptionHandler annotated with @RestControllerAdvice catches these exceptions and converts them into a unified JSON structure using our Result wrapper (code, msg, data).
This keeps controllers clean and provides a consistent error contract for the frontend.

Overall, the architecture is clean and extensible:
controllers focus on HTTP, services focus on business logic, mappers focus on persistence,
and cross-cutting concerns like authentication, user context, auditing, and error handling are implemented via interceptors, ThreadLocal, AOP, and global exception handling.

ä½ å¯ä»¥æŒ‰é¢è¯•æ—¶é—´é•¿çŸ­ï¼Œåˆ å‡ä¸€äº›å¥å­ï¼Œä½†é€»è¾‘é¡ºåºç›´æ¥ç”¨è¿™å¥—ã€‚

â¸»

# â‘¢ é€‰ Category èµ°ä¸€éå…¨æµç¨‹ï¼šHTTP â†’ Controller â†’ Service â†’ Mapper â†’ AOP â†’ DB

æˆ‘ä»¬ç”¨ä½ è´´è¿‡çš„ CategoryController åšâ€œä»å‰ç«¯åˆ°æ•°æ®åº“â€çš„å®Œæ•´é“¾è·¯ç¤ºæ„ã€‚

åœºæ™¯ï¼šç®¡ç†å‘˜æ–°å¢ä¸€ä¸ªåˆ†ç±»ï¼ˆæ¯”å¦‚ï¼šå·èœï¼‰

# ç¬¬ 1 æ­¥ï¼šå‰ç«¯å‘ HTTP è¯·æ±‚
- 	URLï¼šPOST /admin/category
- 	Headerï¼štoken: <ç®¡ç†å‘˜ JWT>
- 	Bodyï¼ˆJSONï¼‰ï¼š
```
{
  "name": "å·èœ",
  "type": 1,
  "sort": 10
}
```

# ç¬¬ 2 æ­¥ï¼šController æ”¶åˆ°è¯·æ±‚ï¼ˆDTOï¼‰
```
@PostMapping
@ApiOperation("æ–°å¢åˆ†ç±»")
public Result<String> save(@RequestBody CategoryDTO categoryDTO){
    log.info("æ–°å¢åˆ†ç±»ï¼š{}", categoryDTO);
    categoryService.save(categoryDTO);
    return Result.success();
}
```
è¿™é‡Œï¼š
- 	@RequestBody CategoryDTOï¼šæŠŠ JSON æ˜ å°„æˆ DTO
- 	Controller ä¸å†™ä¸šåŠ¡ï¼Œåªè°ƒç”¨ categoryService.save(...)
- 	ç”¨ Result.success() ç»Ÿä¸€ç»™å‰ç«¯ä¸€ä¸ªæ ‡å‡†å¤–å£³ï¼ˆcode=1ï¼‰

# ç¬¬ 3 æ­¥ï¼šService å¤„ç†ä¸šåŠ¡ + ç»„è£… Entity

å‡è®¾ CategoryServiceImpl.save å¤§æ¦‚åƒè¿™æ ·ï¼ˆä¼ªä»£ç ï¼‰ï¼š
```
@Service
public class CategoryServiceImpl implements CategoryService {

    @Autowired
    private CategoryMapper categoryMapper;

    @Override
    public void save(CategoryDTO categoryDTO) {
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO, category);
        // è®¾ç½®é»˜è®¤çŠ¶æ€ï¼šå¯ç”¨
        category.setStatus(StatusConstant.ENABLE);

        // â­ ä¸éœ€è¦åœ¨è¿™é‡Œè®¾ç½® createTime / createUser / updateTime / updateUser
        categoryMapper.insert(category);
    }
}
```
Service åšçš„äº‹ï¼š
- 	å…¥å‚ DTO â†’ Entity
- 	è¡¥å……ä¸šåŠ¡å­—æ®µï¼ˆæ¯”å¦‚ statusï¼‰
- 	è°ƒç”¨ Mapperï¼Œäº¤ç»™æŒä¹…å±‚

# ç¬¬ 4 æ­¥ï¼šMapper æ¥å£ + @AutoFill æ³¨è§£
```
@Mapper
public interface CategoryMapper {

    @AutoFill(OperationType.INSERT)
    void insert(Category category);

    // å…¶ä»–æ–¹æ³•çœç•¥â€¦
}
```
- 	@AutoFill(OperationType.INSERT) = æç¤º AOPï¼šè¿™æ˜¯â€œæ’å…¥â€æ“ä½œ

# ç¬¬ 5 æ­¥ï¼šAOP åˆ‡é¢ AutoFillAspect ä»‹å…¥

è°ƒç”¨é¡ºåºå…¶å®æ˜¯ï¼š

Service è°ƒç”¨ Mapper.insert â†’
å…ˆè¿› AutoFillAspect.@Before â†’ å¸®ä½ å¡«å…¬å…±å­—æ®µ â†’
å†çœŸæ­£æ‰§è¡Œ MyBatis INSERT SQL

å…³é”®é€»è¾‘ä½ å·²ç»æœ‰äº†ï¼š
```
@Before("autoFillPointCut()")
public void autoFill(JoinPoint joinPoint){
    // 1. æ‹¿åˆ°æ–¹æ³•ä¸Šçš„ @AutoFill æ³¨è§£ï¼Œå¾—åˆ° OperationType (INSERT)
    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
    AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);
    OperationType operationType = autoFill.value();

    // 2. æ‹¿åˆ°å‚æ•°é‡Œçš„å®ä½“å¯¹è±¡ Category
    Object[] args = joinPoint.getArgs();
    if(args == null || args.length == 0){
        return;
    }
    Object entity = args[0];

    // 3. å‡†å¤‡å½“å‰æ—¶é—´ã€å½“å‰ç”¨æˆ·
    LocalDateTime now = LocalDateTime.now();
    Long currentId = BaseContext.getCurrentId(); // ä» ThreadLocal æ‹¿ç™»å½•ç”¨æˆ· id

    // 4. INSERT æ—¶åå°„è°ƒç”¨ setCreateTime / setCreateUser / setUpdateTime / setUpdateUser
    if(operationType == OperationType.INSERT){
        try {
            Method setCreateTime = entity.getClass()
                .getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
            Method setCreateUser = entity.getClass()
                .getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
            Method setUpdateTime = entity.getClass()
                .getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass()
                .getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            setCreateTime.invoke(entity, now);
            setCreateUser.invoke(entity, currentId);
            setUpdateTime.invoke(entity, now);
            setUpdateUser.invoke(entity, currentId);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```


æ‰€ä»¥ï¼Œåˆ°çœŸæ­£æ‰§è¡Œ SQL ä¹‹å‰ï¼ŒCategory å¯¹è±¡å˜æˆï¼š
```
name = "å·èœ"
type = 1
sort = 10
status = 1           // å¯ç”¨
createTime = now     // AutoFill å¡«çš„
createUser = adminId // AutoFill å¡«çš„
updateTime = now     // AutoFill å¡«çš„
updateUser = adminId // AutoFill å¡«çš„
```

ç¬¬ 6 æ­¥ï¼šMyBatis ç”Ÿæˆ SQL â†’ DB è½åº“
```
MyBatis Mapper XML é‡Œçš„ insert è¯­å¥ä¼šç±»ä¼¼ï¼š

INSERT INTO category
(name, type, sort, status,
 create_time, create_user, update_time, update_user)
VALUES
(#{name}, #{type}, #{sort}, #{status},
 #{createTime}, #{createUser}, #{updateTime}, #{updateUser});
```
æœ€ç»ˆæ•°æ®è¿›è¡¨çš„æ—¶å€™ï¼Œå·²ç»æœ‰ï¼š
- 	è°åˆ›å»ºçš„ï¼ˆcreate_userï¼‰
- 	ä»€ä¹ˆæ—¶å€™åˆ›å»ºï¼ˆcreate_timeï¼‰
- 	æœ€è¿‘ä¸€æ¬¡æ˜¯è°æ”¹çš„ï¼ˆupdate_userï¼‰
- 	ä»€ä¹ˆæ—¶å€™æ”¹çš„ï¼ˆupdate_timeï¼‰

åŒä¸€å¥—é€»è¾‘ï¼ŒOrders / User / Dish è¿™äº›å®ä½“ä¹Ÿéƒ½å¯ä»¥å¤ç”¨ã€‚
åªè¦å®ƒä»¬æœ‰è¿™å‡ ä¸ªå­—æ®µï¼Œå¹¶ä¸” Mapper æ–¹æ³•åŠ ä¸Š @AutoFill(OperationType.INSERT / UPDATE)ã€‚

â¸»

å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥å¸®ä½ ï¼š
- 	ç”¨ Orders å†å†™ä¸€å¥—â€œä¸‹å•æµç¨‹è‡ªè¿°ç¨¿â€ï¼ˆä»ç”¨æˆ·ç‚¹ä¸‹å•æŒ‰é’®åˆ°è®¢å•è½åº“ï¼‰
- 	æŠŠ GlobalExceptionHandler + AutoFill + JwtProperties + BaseContext åˆå¹¶æˆâ€œåç«¯åŸºç¡€è®¾æ–½â€ä¸€æ®µï¼Œè¯´æˆ 2 åˆ†é’Ÿå°æ¼”è®²ç¨¿ï¼Œè®©ä½ é¢è¯•æ—¶ä¸€å£æ°”è®²å®Œ ğŸ”¥


å¥½çš„ï¼Œæˆ‘ä»¬ç”¨ä¸­æ–‡æŠŠå…³é”®å†…å®¹è®²æ¸…æ¥š ğŸ˜Š
ï¼ˆæˆ‘ä¼šä¿ç•™é‡ç‚¹ã€ä¾¿äºä½ é¢è¯•æˆ–å¤ä¹ ç›´æ¥ä½¿ç”¨ï¼‰

â¸»

âœ… GlobalExceptionHandler æ˜¯ä»€ä¹ˆï¼Ÿï¼ˆä¸€å¥è¯ç‰ˆï¼‰

ç»Ÿä¸€å¤„ç†åç«¯å¼‚å¸¸ï¼Œå¹¶è¿”å›ç»Ÿä¸€æ ¼å¼çš„ JSON ç»™å‰ç«¯

â¸»

â‘  GlobalExceptionHandlerï¼ˆå®Œæ•´å¯ç›´æ¥ç”¨ï¼‰
```
package com.sky.handler;

import com.sky.exception.BaseException;
import com.sky.result.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    // å¤„ç†ä¸šåŠ¡å¼‚å¸¸
    @ExceptionHandler(BaseException.class)
    public Result<String> handleBaseException(BaseException e) {
        log.warn("ä¸šåŠ¡å¼‚å¸¸: {}", e.getMessage());
        return Result.error(e.getMessage());
    }

    // å¤„ç†å…¶ä»–æœªæ•è·å¼‚å¸¸
    @ExceptionHandler(Exception.class)
    public Result<String> handleException(Exception e) {
        log.error("ç³»ç»Ÿå¼‚å¸¸: ", e);
        return Result.error("æœåŠ¡å™¨å¼€å°å·®äº†ï¼Œè¯·ç¨åé‡è¯•");
    }
}
```
ğŸ‘‰ æ•ˆæœï¼š
- 	throw new OrderBusinessException("è®¢å•ä¸å­˜åœ¨")
- 	â†’ ç»Ÿä¸€å˜æˆï¼š
```
{
  "code": 0,
  "msg": "è®¢å•ä¸å­˜åœ¨",
  "data": null
}
```

â¸»

â‘¡ é¡¹ç›®æ¶æ„ä¸­æ–‡è‡ªæˆ‘ä»‹ç»ï¼ˆé¢è¯•å¯ç›´æ¥èƒŒï¼‰

æˆ‘ä»¬é¡¹ç›®é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼š
Controller è´Ÿè´£æ¥æ”¶è¯·æ±‚ä¸è¿”å› Responseï¼Œ
Service å±‚è´Ÿè´£ä¸šåŠ¡é€»è¾‘ï¼Œ
Mapper å±‚è´Ÿè´£æ•°æ®åº“æ“ä½œï¼Œæ¡†æ¶æ˜¯ MyBatisã€‚

æˆ‘ä»¬æŠŠæ•°æ®å¯¹è±¡åšäº†èŒè´£æ‹†åˆ†ï¼š
DTO ç”¨æ¥æ¥æ”¶å‰ç«¯å…¥å‚ï¼Œ
Entity å¯¹åº”æ•°æ®åº“è¡¨ï¼Œ
VO ç”¨äºè¿”å›ç»™å‰ç«¯å±•ç¤ºå±‚ã€‚

ç™»å½•è®¤è¯ä½¿ç”¨ JWTï¼Œ
é€šè¿‡æ‹¦æˆªå™¨è§£æ tokenï¼Œ
ç”¨æˆ· id å­˜å…¥ ThreadLocalï¼ˆBaseContextï¼‰ï¼Œ
å„å±‚æ— éœ€ä¼ å‚å³å¯è·å–å½“å‰ç”¨æˆ·ã€‚

å…¬å…±å­—æ®µå¦‚ createTimeã€updateTimeã€createUserã€updateUser
é€šè¿‡è‡ªå®šä¹‰æ³¨è§£ @AutoFill + AOP è‡ªåŠ¨å¡«å……ï¼Œ
åœ¨ Mapper å±‚è°ƒç”¨å‰è‡ªåŠ¨è¡¥å…¨ï¼Œé¿å…é‡å¤ä»£ç ã€‚

å¼‚å¸¸ä½“ç³»æ–¹é¢ï¼š
BaseException ç»§æ‰¿ RuntimeExceptionï¼Œ
å„ä¸šåŠ¡å¼‚å¸¸ç»§æ‰¿ BaseExceptionï¼Œ
å…¨å±€å¼‚å¸¸å¤„ç†å™¨ç»Ÿä¸€è½¬æ¢ä¸ºæ ‡å‡† Result JSONã€‚

è¿™æ ·è®¾è®¡ä½¿ä¸šåŠ¡è§£è€¦ã€èŒè´£æ¸…æ™°ï¼Œä¹Ÿç¬¦åˆä¼ä¸šåç«¯å¼€å‘å®é™…æ¨¡å¼ã€‚

â¸»

â‘¢ ç”¨â€œæ–°å¢åˆ†ç±»â€ä¸ºä¾‹èµ°å®Œæ•´æµç¨‹

â­ åœºæ™¯ï¼šæ–°å¢åˆ†ç±»ã€Œå·èœã€

# 1ï¼‰å‰ç«¯è¯·æ±‚
```
POST /admin/category
token: xxx

{
  "name": "å·èœ",
  "type": 1,
  "sort": 10
}
```


# 2ï¼‰Controller
```
@PostMapping
public Result<String> save(@RequestBody CategoryDTO categoryDTO){
    categoryService.save(categoryDTO);
    return Result.success();
}
```
ğŸ‘‰ Controllerï¼š
- 	åªæ¥æ”¶/è¿”å›
- 	ä¸å†™ä¸šåŠ¡

# 3ï¼‰Service

public void save(CategoryDTO dto){
    Category c = new Category();
    BeanUtils.copyProperties(dto, c);
    c.setStatus(1);
    categoryMapper.insert(c);
}

ğŸ‘‰ ä¸ç”¨ç®¡ createTime/createUser
ğŸ‘‰ åé¢ AOP ä¼šè‡ªåŠ¨åš

# 4ï¼‰Mapper

@AutoFill(OperationType.INSERT)
void insert(Category category);

# 5ï¼‰AutoFillAspect è‡ªåŠ¨å¡«å……å…¬å…±å­—æ®µ
- 	æ‹¦æˆª mapper
- 	åˆ¤æ–­ INSERT / UPDATE
- 	é€šè¿‡åå°„è°ƒç”¨ setter
- 	è®¾ç½®ï¼š
  
```
createTime
createUser
updateTime
updateUser
```

6ï¼‰æœ€ç»ˆå…¥åº“

æ•°æ®åº“æ”¶åˆ°å®Œæ•´æ•°æ®ï¼š

| å­—æ®µ | å€¼ |
|------|------|
| name | å·èœ |
| create_time | å½“å‰æ—¶é—´ |
| create_user | å½“å‰ç™»å½•ç®¡ç†å‘˜ |
| update_time | å½“å‰æ—¶é—´ |
| update_user | å½“å‰ç™»å½•ç®¡ç†å‘˜ |



â¸»

â¤ï¸ ä½ ç°åœ¨å·²ç»æŒæ¡äº†
- 	DTO / Entity / VO
- 	AOP è‡ªåŠ¨å¡«å……
- 	JWT + ThreadLocal
- 	å…¨å±€å¼‚å¸¸å¤„ç†
- 	åˆ†å±‚æ¶æ„å®Œæ•´é“¾è·¯

â¸»

ğŸ‘‰ ä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ç»§ç»­å¸®ä½ ï¼š

ä½ é€‰ä¸€ä¸ªï¼š
	1.	ğŸ” AutoFillAspect é€è¡Œä¸­æ–‡æ³¨é‡Šç‰ˆ
	2.	ğŸ§­ ç”»å®Œæ•´æ¶æ„å›¾ï¼ˆMermaid å›¾å½¢ï¼‰
	3.	ğŸ§ª é¢è¯•é¢˜è®­ç»ƒï¼š10 é“åç«¯é¡¹ç›®æ·±æŒ–é¢˜
	4.	ğŸš€ ä¸‹å•æµç¨‹ï¼šä»ç‚¹å‡»ä¸‹å• â†’ æ”¯ä»˜ â†’ æ•°æ®åº“å…¨æµç¨‹è§£é‡Š
	5.	ğŸ›  æ‰‹å†™ä¸€ä¸ªç®€å• AOP demo å¸¦ä½ ç»ƒæ‰‹

ç›´æ¥å‘Šè¯‰æˆ‘ç¼–å·å³å¯ ğŸ‘


  
